---
title: 第一部分 作用域和闭包（上）
date: 2019-09-05 15:37:14
tags:
  - 读书笔记
  - 《你不知道的JavaScript》
  - JavaScript
  - 前端
---

### 概述

书中总结道，作用域是一套设计良好的，用来存储或访问变量的规则。对于JS来说，这套规则主要主要有以下几点：

1. 作用域嵌套（自下向上，逐级包含）
2. 函数作用域（可以理解为形成局部作用域的规则）
3. 块作用域（可以理解为形成局部作用域的规则）
4. 变量名（/函数名）提升

最后，书中提到由作用域规则而构造的闭包。

### 第一章  作用域是什么

这章扯到了编译原理，提到一般编译的三个步骤：词法分析、语法分析、代码生成。然后通过模拟对话的方式，简单阐述了引擎、编译器、作用域之间的关系。不过我个人觉得没啥卵用，无论是词法分析、语法分析或是代码生成，这些过程都是黑盒子，说破天在这本书里还是黑盒子。

然后介绍了作用域嵌套，感觉这是一般编程语言都会有的作用域规则。


### 第二章  词法作用域

这里提到两种作用域的工作模型：词法作用域和动态作用域。大多数语言都使用的是词法作用域，JavaScript也是。

词法作用域就是定义在词法阶段的作用域，即由你在写代码时将变量和块作用域写在哪里决定（平时可能感觉不到，但仔细一想的话，机器肯定是没有作用域的概念，是语言本身赋予的一种能力，或规则吧）。

文中还提到了一些欺骗词法的手段，比如eval、with等。eval的功能是真的很强大，可以将字符串生成为js代码，with更像是处理对象属性的语法糖。这两个函数都不推荐使用。

### 第三章  函数作用域和块作用域

函数可以隐藏内部实现，同事函数可以形成一个局部的作用域，从而规避冲突。

这章还提到函数表达式，如下：

```javascript
var a = 2;
(function foo() {
  var a = 3;
  console.log(3);  // 3
})();
console.log(a);  // 2
```
函数表达式可以防止函数声明本身造成的命名污染。

文中接着介绍了匿名和具名函数，如下：
```javascript
setTimeout(function() {
  console.log("我是匿名函数...");
})

// 推荐这种写法
setTimeout(function Hello() {
  console.log("我的名字是Hello...");
})
```
书中推荐给函数表达式指定一个函数名，可以增强可读性。

接着书中详细介绍了立即执行函数表达式，如下：

```javascript
// 写法一：
(function IIFE( global ) {
  // ...
})(window);

// 写法二：
(function IIFE( global ) {
   // ...
 }(window));
 
```
参数还可以是函数或其他，可以根据需要更加灵活的使用。

接着书中介绍了块作用域，其实函数也是块作用域的一种。JavaScript可以形成块作用的语法主要有以下几种：

1. 函数
2. for循环
3. if语句
4. try/catch语句

接着指出var声明的缺陷，从而（ES6）引出let、和const关键词。

### 第四章 （变量声明）提升

每级作用域都会进行提升操作，函数声明会被提升，但是函数表达式却不会被提升（即使是具名的函数表达式）
```javascript
foo();
function foo() {
  console.log(a);  // undefined
  var a = 2;
}
// 等同于
function foo() {
  var a;
  console.log(a);  // undefined
  a = 2;
}


foo();  // TypeError  => undefined()
var foo = function bar() {
  // ...
}
// 等同于
var foo;
foo();
foo = function() {
  // var bar = ...self...
}
```

函数声明和变量声明都会被提升，但是函数会首先被提升，尽管重复的var声明会被忽略掉，但出现在后面的函数声明还是可以覆盖前面的
```javascript
foo();  // 1
var foo;
function foo() {
  console.log(1);
}
foo = function() {
  console.log(2);
}
// 等同于
function foo() {
  console.log(1);
}
foo();
foo = function() {
  console.log(2);
}
```
总结一下就是，变量（包括函数声明）的声明和赋值是两个操作，声明会首先被提升到本级作用域。

### 第五章 作用域闭包
书中解释：当函数可以记住并且访问所在的词法作用域，即使函数是在当前词法作用域之外执行，这时就产生了闭包。
MDN（https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Closures ）的解释：函数与对其状态即词法环境（lexical environment）的引用共同构成闭包（closure）。

关键就是函数，以及函数所持有的局部作用域的引用。闭包可以说是js早期模块化不可缺少的核心。
书中提到的几个和闭包相关的关键点：
1. 回调函数和闭包：只要使用了回调函数，实际上就是在使用闭包
2. 块作用域和闭包：循环/if
3. 模块机制

